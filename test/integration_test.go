//go:build integration
// +build integration

package test

import (
	"net/http"
	"net/http/httptest"
	"os"
	"path/filepath"
	"strings"
	"testing"

	"context"

	"github.com/alexey-ott/planet-go/internal/cache"
	"github.com/alexey-ott/planet-go/internal/config"
	"github.com/alexey-ott/planet-go/internal/fetcher"
	"github.com/alexey-ott/planet-go/internal/filter"
	"github.com/alexey-ott/planet-go/internal/renderer"
)

func TestIntegration_FullPipeline(t *testing.T) {
	// Create test HTTP server serving RSS feed
	server := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		w.Header().Set("Content-Type", "application/rss+xml")
		w.Header().Set("ETag", "test-etag-123")
		w.Write([]byte(`<?xml version="1.0"?>
<rss version="2.0">
  <channel>
    <title>Test Blog</title>
    <link>http://example.com</link>
    <description>A test blog</description>
    <item>
      <title>First Post about Clojure</title>
      <link>http://example.com/post/1</link>
      <description>This is a post about Clojure programming</description>
      <pubDate>Mon, 01 Jan 2024 12:00:00 GMT</pubDate>
      <author>John Doe</author>
    </item>
    <item>
      <title>Second Post about Go</title>
      <link>http://example.com/post/2</link>
      <description>This is a post about Go programming</description>
      <pubDate>Mon, 02 Jan 2024 12:00:00 GMT</pubDate>
      <author>Jane Smith</author>
    </item>
    <item>
      <title>Spam Post</title>
      <link>http://example.com/post/3</link>
      <description>Buy now! Special offer!</description>
      <pubDate>Mon, 03 Jan 2024 12:00:00 GMT</pubDate>
    </item>
  </channel>
</rss>`))
	}))
	defer server.Close()

	// Setup test directories
	tmpDir := t.TempDir()
	cacheDir := filepath.Join(tmpDir, "cache")
	outputDir := filepath.Join(tmpDir, "output")

	// Create config
	cfg := &config.Config{
		Planet: config.PlanetConfig{
			Name:           "Test Planet",
			Link:           "http://planet.example.com",
			OwnerName:      "Test Owner",
			OwnerEmail:     "test@example.com",
			CacheDirectory: cacheDir,
			OutputDir:      outputDir,
			LogLevel:       "INFO",
			FeedTimeout:    20,
			ItemsPerPage:   10,
			DateFormat:     "2006-01-02",
			TemplateFiles:  []string{"test.html.tmpl"},
			Filter:         "",     // No include filter
			Exclude:        "Spam", // Exclude spam
		},
		Feeds: []config.FeedConfig{
			{URL: server.URL, Name: "Test Blog"},
		},
	}

	// Step 1: Fetch feeds
	cache := cache.New(cacheDir)
	fetcher := fetcher.NewSequential(20, cache, false)

	results := fetcher.FetchFeeds(context.Background(), cfg.Feeds)

	if len(results) != 1 {
		t.Fatalf("expected 1 result, got %d", len(results))
	}

	result := results[0]
	if result.Error != nil {
		t.Fatalf("fetch failed: %v", result.Error)
	}

	if len(result.Entries) != 3 {
		t.Fatalf("expected 3 entries, got %d", len(result.Entries))
	}

	// Step 2: Load all entries from cache
	entries, err := cache.LoadAll()
	if err != nil {
		t.Fatalf("failed to load entries: %v", err)
	}

	if len(entries) != 3 {
		t.Fatalf("expected 3 cached entries, got %d", len(entries))
	}

	// Step 3: Apply filters
	filter, err := filter.New(cfg.Planet.Filter, cfg.Planet.Exclude)
	if err != nil {
		t.Fatalf("failed to create filter: %v", err)
	}

	filtered := filter.Apply(entries)

	// Should exclude the spam post
	if len(filtered) != 2 {
		t.Fatalf("expected 2 filtered entries, got %d", len(filtered))
	}

	// Verify spam was filtered out
	for _, entry := range filtered {
		if strings.Contains(entry.Title, "Spam") {
			t.Error("spam entry was not filtered out")
		}
	}

	// Step 4: Render template
	tmplPath := filepath.Join(tmpDir, "test.html.tmpl")
	tmplContent := `<!DOCTYPE html>
<html>
<head><title>{{.Name}}</title></head>
<body>
<h1>{{.Name}}</h1>
<p>Owner: {{.OwnerName}} &lt;{{.OwnerEmail}}&gt;</p>
{{range .Items}}
<article>
  <h2><a href="{{.Link}}">{{.Title}}</a></h2>
  {{if .Author}}<p>By {{.Author}}</p>{{end}}
  <div>{{.Content}}</div>
</article>
{{end}}
<footer>Generated by {{.Generator}}</footer>
</body>
</html>`

	if err := os.WriteFile(tmplPath, []byte(tmplContent), 0644); err != nil {
		t.Fatal(err)
	}

	cfg.Planet.TemplateFiles = []string{tmplPath}

	renderer := renderer.New(outputDir)
	if err := renderer.Render(tmplPath, filtered, cfg); err != nil {
		t.Fatalf("render failed: %v", err)
	}

	// Step 5: Verify output
	outputPath := filepath.Join(outputDir, "test.html")
	content, err := os.ReadFile(outputPath)
	if err != nil {
		t.Fatalf("failed to read output: %v", err)
	}

	html := string(content)

	// Verify content
	if !strings.Contains(html, "Test Planet") {
		t.Error("output missing planet name")
	}

	if !strings.Contains(html, "Test Owner") {
		t.Error("output missing owner name")
	}

	if !strings.Contains(html, "First Post about Clojure") {
		t.Error("output missing first post")
	}

	if !strings.Contains(html, "Second Post about Go") {
		t.Error("output missing second post")
	}

	if strings.Contains(html, "Spam Post") {
		t.Error("output contains filtered spam post")
	}

	if !strings.Contains(html, "Planet Go") {
		t.Error("output missing generator name")
	}

	t.Logf("Integration test passed! Output:\n%s", html)
}

func TestIntegration_ConditionalGET(t *testing.T) {
	requestCount := 0
	etag := "test-etag-456"

	// Create test server that supports conditional GET
	server := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		requestCount++

		// Check for If-None-Match header
		if r.Header.Get("If-None-Match") == etag {
			w.WriteHeader(http.StatusNotModified)
			return
		}

		w.Header().Set("Content-Type", "application/rss+xml")
		w.Header().Set("ETag", etag)
		w.Write([]byte(`<?xml version="1.0"?>
<rss version="2.0">
  <channel>
    <title>Test Feed</title>
    <link>http://example.com</link>
    <item>
      <title>Test Item</title>
      <link>http://example.com/1</link>
      <description>Test</description>
      <pubDate>Mon, 01 Jan 2024 00:00:00 GMT</pubDate>
    </item>
  </channel>
</rss>`))
	}))
	defer server.Close()

	tmpDir := t.TempDir()
	cache := cache.New(tmpDir)
	fetcher := fetcher.NewSequential(20, cache, false)

	feeds := []config.FeedConfig{{URL: server.URL, Name: "Test"}}

	// First fetch
	results1 := fetcher.FetchFeeds(context.Background(), feeds)
	if len(results1) != 1 || results1[0].Error != nil {
		t.Fatal("first fetch failed")
	}
	if results1[0].Cached {
		t.Error("first fetch should not be cached")
	}

	// Second fetch (should get 304 Not Modified)
	results2 := fetcher.FetchFeeds(context.Background(), feeds)
	if len(results2) != 1 || results2[0].Error != nil {
		t.Fatal("second fetch failed")
	}
	if !results2[0].Cached {
		t.Error("second fetch should be cached")
	}

	if requestCount != 2 {
		t.Errorf("expected 2 requests, got %d", requestCount)
	}
}

func TestIntegration_MultipleFeeds(t *testing.T) {
	// Create multiple test servers
	server1 := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		w.Header().Set("Content-Type", "application/rss+xml")
		w.Write([]byte(`<?xml version="1.0"?>
<rss version="2.0">
  <channel>
    <title>Feed 1</title>
    <link>http://example1.com</link>
    <item>
      <title>Post from Feed 1</title>
      <link>http://example1.com/1</link>
      <description>Content from feed 1</description>
      <pubDate>Mon, 01 Jan 2024 12:00:00 GMT</pubDate>
    </item>
  </channel>
</rss>`))
	}))
	defer server1.Close()

	server2 := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		w.Header().Set("Content-Type", "application/atom+xml")
		w.Write([]byte(`<?xml version="1.0"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Feed 2</title>
  <link href="http://example2.com"/>
  <entry>
    <title>Post from Feed 2</title>
    <link href="http://example2.com/1"/>
    <content>Content from feed 2</content>
    <updated>2024-01-02T12:00:00Z</updated>
  </entry>
</feed>`))
	}))
	defer server2.Close()

	tmpDir := t.TempDir()
	cache := cache.New(tmpDir)
	fetcher := fetcher.NewSequential(20, cache, false)

	feeds := []config.FeedConfig{
		{URL: server1.URL, Name: "Feed 1"},
		{URL: server2.URL, Name: "Feed 2"},
	}

	// Fetch both feeds
	results := fetcher.FetchFeeds(context.Background(), feeds)

	if len(results) != 2 {
		t.Fatalf("expected 2 results, got %d", len(results))
	}

	for i, result := range results {
		if result.Error != nil {
			t.Errorf("feed %d failed: %v", i, result.Error)
		}
		if len(result.Entries) == 0 {
			t.Errorf("feed %d has no entries", i)
		}
	}

	// Load all entries
	entries, err := cache.LoadAll()
	if err != nil {
		t.Fatalf("failed to load entries: %v", err)
	}

	if len(entries) != 2 {
		t.Fatalf("expected 2 total entries, got %d", len(entries))
	}
}
